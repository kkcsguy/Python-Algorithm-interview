## 6.用两个栈模拟队列操作

&emsp;&emsp;假设用栈A与栈B模拟队列Q，A为插入栈，B为弹出栈，以实现队列Q。

### 6.1思路

&emsp;&emsp;假设A和B都为空,要入队列，入栈A即可，而出队列则需要分两种情况考虑：

&emsp;&emsp;(1)如果栈B不为空，则直接弹出栈B的数据。

&emsp;&emsp;(2)如果栈B为空，则依次弹出栈A的数据，放入栈B中，再弹出栈B的数据。

### 6.2性能分析

&emsp;&emsp;入队列操作的时间复杂度为O(1)，出队列操作的时间复杂度则依赖于入队列与出队列执行的评率。总的来说，出队列操作的时间复杂度为O(1)。



## 7.如何设计一个排序系统

&emsp;&emsp;本题不仅要实现队列常见的入队列和出队列的功能，而且还需要实现队列中任意一个元素都可以随时出队列，且出队列后需要更新队列用户位置的变化。

&emsp;&emsp;可以用到python一个神奇的库：**collections--容器数据类型**

**&emsp;&emsp;deque** :类似列表的容器,实现了在两端快速添加(append)和弹出(pop)

&emsp;&emsp;返回一个双向队列对象(double-ended queue)

```python
class collections.deque([interable[,maxlen]])
    
    append(x):添加到右端
    appendleft(x):添加到左端
    clear():移除所有元素
    copy():创建浅拷贝
    count(x):计算x的个数
    extend(interable):扩展右侧
    extendleft(interable):扩展左侧
    index(x[,start[,stop]]):返回第x个元素
    insert(i,x):在位置i插入x
    pop():移除并返回最右边元素
    popleft():移除并返回最左边元素
    remove(value):移去找到的第一个value
    reverse():逆序排列
```

## 8.如何实现LRU缓存方案

&emsp;&emsp;使用两个数据结构实现一个LRU缓存。

&emsp;&emsp;(1)使用双向队列，队列的最大容量为缓存的大小。在使用过程中，把最近使用的页面移动到队列头，最近没有使用的页面将被放在队列尾的位置。

&emsp;&emsp;(2)使用一个哈希表，把页号作为键，把缓存在队列中的结点的地址作为值。

&emsp;&emsp;当引用一个页面时，如果所需的页面在内存中，只需要把这个页对应的结点移动到队列的前面。如果所需的页面不在内存中，此时需要把这个页面加载到内存中。



## 9.如何从给定的车票中找出旅程

### 9.1 拓扑排序

&emsp;&emsp;一般而言可以用拓扑排序进行解答。根据车票信息构建一个图，然后找出这张图的拓扑排序序列，这个序列就是旅程的路线。时间复杂度为O(N)。

### 9.2hash法

&emsp;&emsp;主要的思路为根据车票信息构建一个字典，然后从这个字典中找到整个旅程的起点，接着就可以从起点出发依次寻找下一站，进而知道终点，具体思路为：

&emsp;&emsp;(1)根据车票的出发地与目的地构建字典。

`Tickets={(“西安”到“成都”)，(“背景”到“上海”),(“大连”到“西安”)，(“上海”到“大连”)}`

&emsp;&emsp;(2)构建Tickets的逆向字典如下：

`ReverseTickets={(“成都”到“西安”)，(“上海”到“北京”),(“西安”到“大连”)，(“大连”到“上海”)}`

&emsp;&emsp;(3)遍历Tickets，对于遍历到的key值，判断这个值是否在ReverseTickets中的key中存在，如果不存在，那么说明遍历到的Tickets中的值就是旅途的起点。

### 9.3 性能分析

&emsp;&emsp;时间复杂度为O(N)，空间复杂度为O(N)。



## 10.数组中找出条件数对

&emsp;&emsp;找数对中满足a+b=c+d的两个数对。

### 10.1 字典法

&emsp;&emsp;以数对为单位进行遍历，在遍历过程中，把数对和数对的值存储在字典中，当遍历到一个键值对时，如果它的和在字典中已经存在，那么就找到了满足条件的键值对。

&emsp;&emsp;需要注意的是，字典中的值可以是任何类型，而键的要求就比较高，一般用数字、字符串、元组，在这里键取数对的和，值取数对。

### 10.2 性能分析

&emsp;&emsp;时间复杂度为O(n^2)，因为使用了双重循环。