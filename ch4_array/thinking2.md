## 9.求数组连续最大和

&emsp;&emsp;可以使用**动态规划**的方法来降低算法的时间复杂度。首先可以根据数组的最后一个元素arr[n-1]与最大子数组的关系来讨论：

1. 最大子数组包含arr[n-1]；
2. arr[n-1]单独构成最大子数组；
3. 最大子数组不包含arr[n-1]，那么求arr[1..n-1]的最大子数组转换为求arr[1..n-1]的最大子数组。

&emsp;&emsp;假设计算出arr[1..n-2]的最大子数组的和为MaxArr[i-2]，同时也计算出arr[0..i-1]中包含arr[i-1]的最大子数组的和EndArr[i-1]。则可以得出MaxArr[i-1]=max(EndArr[i-1],arr[i-1],MaxArr[i-2])。

## 10.寻找出现1次的数

&emsp;&emsp;根据题目描述，可以得到几个有用信息：1.数组中元素个数为奇数个；2.由于三个数组出现过一次，则它们对应的二进制数也不可能完全相同。当我们根据二进制上某一位的1、0值来划分出两个数组，那么奇数个元素的数组通过**异或**就能得到出现1次的数。

&emsp;&emsp;**性能分析**：这种方法用了两层循环，总共循环执行的次数为64*N，算法的时间复杂度为O(N)。

## 11.不排序求中位数

&emsp;&emsp;快速排序算法在每一次局部递归后都保证某个元素左侧的元素的值都比它小，右侧的元素的值都比它大，因此可以利用这个思路快速地找到第N大元素。可以采用类快速排序的方法。首先把问题转化为求一列数中第i小的数的额问题。当使用一次类快速排序算法后，分隔元素的下标为pos：

1. 当pos>length/2时，说明中位数在数组左半部分；
2. 当pos=length/2时，说明找到该中位数；
3. 当pos<length/2时，说明中位数在数组右半部分。

&emsp;&emsp;**性能分析**：这种方法在平均情况下的时间复杂度为O(N)。

## 12.对数组循环移位

&emsp;&emsp;由于有空间复杂度的要求，只能在原数组中进行右移。又有O(N)的时间复杂度要求，不能使用蛮力法，**翻转法**可以满足O(N)的时间复杂度、2个附加变量的空间复杂度要求。

&emsp;&emsp;把数组看成由两端组成的，记为XY。先在数组上定义一种翻转的操作，就是翻转数组中数字的先后顺序。$(X^T Y^T) ^T=YX$。回到这道题，把数组分成两段，在定义一个翻转子数组的函数，按照前面的步骤翻转三次就行了。时间复杂度和空间复杂度都合乎要求。