## 13.按要求构造数组

&emsp;&emsp;如果没有是时间复杂度与空间复杂度的要求，算法将非常简单，首先遍历一遍数组a，计算数组a中所有元素乘积，并保存到一个临时遍历tmp，然后再遍历一遍数组a并给数组赋值：b[i]=tmp/a[i]，但是这种方法使用了一个临时变量，也不满足题目要求。

&emsp;&emsp;计算b[i]时，先遍历一遍数组a，过程中对数组b进行赋值：b[i]=a[i-1]*b[i-1]，这样经过一次遍历后，数组b的值为b[i]=a[0]...a[i-1]。因为不允许使用除法，将b[i]在乘以a[i+1]...a[N-1]，实现方法为逆向遍历数组a，把数组后半段值的乘积记录到b[0]中，通过b[i]与b[0]的乘积就可以得到满足题目要求的b[i]。

## 14.求解迷宫问题

&emsp;&emsp;**回溯法**：当碰到死胡同的时候，回溯到前一步，然后从前一步出发继续寻找可达的路径。申请一个结果矩阵来标记移动的路径。

1. 在结果矩阵中标记当前为1；
2. 向右前进一步，然后递归地检查，走完这一步后，判断是否存在到终点的可达的路线；
3. 如果步骤2中的移动方法导致没有通往终点的路径，那么选择向下移动一步，然后检查是否存在到终点的可达的路线；
4. 如果上面的移动方法都会导致没有可达的路径，那么标记当前单元格在结果矩阵中为0，返回false，并回溯到前一步中。

## 15.三个有序数组中找公共元素

&emsp;&emsp;假设当前遍历的三个数组的元素分别为arr1[i]、arr2[j]、arr3[k]，，则存在以下几种可能：

1. 如果arr1[i]、arr2[j]、arr3[k]相等，则说明当前遍历的元素是三个数组的公共元素，然后数组后移；
2. 如果arr1[i]<arr2[j]，则执行i+来继续遍历arr1后面的元素；
3. 如果arr2[j]<arr3[k]，则执行j+来继续遍历arr2后面的元素；
4. 如果前面都不满足，说明arr1[i]>arr2[j]而且arr2[j]>arr3[k]，此时可以通过k+来遍历arr3后面的元素。

&emsp;&emsp;**性能分析**：这种方法的时间复杂度为O(N1+N2+N3)。

## 16.对有大量重复元素的数组排序

### 16.1 AVL树

&emsp;&emsp;根据数组中的数构建一个AVL树，这里需要对AVL树做适当的扩展，在结点中增加一个额外的数据域来记录这个数字出现的次数，在AVL树构建完成后，可以对AVL树进行中序遍历，根据每个结点对应数字出现的次数，把遍历结果放回数组中就完成了排序。

&emsp;&emsp;AVL树是最先发明的**自平衡二叉查找树**。在AVL树中任何结点的两个子树的高度最大差别为1，所以它也被称作**高度平衡树**。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。

&emsp;&emsp;**性能分析**：这种方法的时间复杂度为O($N \log _2 ^M$)，N为数组大小，M为数组中不同数字的个数，空间复杂度为O(N)。

### 16.2 哈希法

&emsp;&emsp;创建一个哈希表，然后遍历数组，把数组中的数字放入哈希表中，在遍历的过程中，如果这个数在哈希表中存在，则直接把哈希表中这个key对应的value加1；如果这个数在哈希表中不存在，则直接把这个数添加到哈希表中，并且初始化这个key对应的value为1。

&emsp;&emsp;**性能分析**：时间复杂度为O(N+$M\log _2 ^M$),空间复杂度为O(M)。

## 17.对任务进行调度

&emsp;&emsp;可以采用**贪心算法**来解决，申请一个数组来记录每台机器的执行时间，初始化为0，在调度任务的时候，对于每个任务，在选取机器的时候采用如下的**贪心策略**：对于每台机器，计算机器已经分配任务的执行时间+这个任务需要的时间，选用最短时间的机器进行处理。

&emsp;&emsp;**性能分析**：这种方法使用了双重循环，因此，时间复杂度为O(MN)。

## 18.对磁盘分区

&emsp;&emsp;本体的主要思路如下：对所有的分区进行遍历，同时用一个遍历dIndex记录上次分配磁盘的下标，初始化为0：对于每个分区，从上次分配的磁盘开始继续分配，如果没有足够的空间，则顺序找其他的磁盘，直到找到合适的磁盘为止，进行分配；如果找不到合适的磁盘，则分配失败。

&emsp;&emsp;**性能分析**：这种方法使用了双重循环，时间复杂度为O(MN)。

