#9-12题的思路与结果
'''
9.py    指针指向法
分别用指针head1,head2来遍历两个链表，如果当前head1指向的数据小于head2指向的数据，则将head1指向的结点归入合并后的链表中，
否则，将head2指向的结点归入合并后的链表中。如果有一个遍历结束，则把未结束的链表连接到合并后的链表尾部。
链表升序排列

只需要对链表进行一次遍历，时间复杂度为O(N)；只需要几个指针变量来保存结点的地址信息，空间复杂度为O(1)。
'''

'''
10.py   复制数据删除法
一般而言，要删除单链表中的一个结点p，首先需要找到结点p的前驱节点pre，然后通过pre.next=p.next来实现对结点p的删除。
对于本题而言，无法获取结点p的前驱节点。因此，不能采用这种传统方法。
分两种情况分析：
(1)如果这个结点是链表的最后一个结点，那么无法删除这个结点。
(2)如果这个结点不是链表的最后一个结点，可以通过把其后继结点的数据复制到当前结点中，然后删除后继结点的方法来实现。

不需要遍历链表，只需要完成一个数据复制与结点删除的操作，时间复杂度为O(1);用了常数个额外指针变量，空间复杂度为O(1)。
'''

'''
Hash法
如果两个链表相交，那么他们会有公共的结点，由于结点的地址或引用可以作为结点的唯一表示，因此，可以通过判断两个链表中的结点是否有相同的地址或引用来判断链表是否相交。
首先，遍历链表head1，把遍历到的所有结点的地址存放到HashSet中;接着遍历head2，每遍历到一个结点，就判断这个结点的地址在HashSet中是否存在。
需要遍历两个链表，时间复杂度为O(n1+n2);需要额外申请储存空间来储存链表head1中结点的地址，空间复杂度为O(n1)。

首尾相接法
主要思路：将这两个链表首尾相连，检测这个链表是否存在环，如果存在，则链表相交，而环入口结点即为相交的结点。环相交见本章第6题

尾结点法    11.py
主要思路：如果两个链表相交，那么两个链表从相交点到链表结束都是相同的结点，必然是Y字形，判断两个链表的最后一个结点是不是相同即可。
依次遍历两个链表，如果走到同样的尾结点，则两个链表相交，记下长度n1,n2,长链表结点先出发前进|n1-n2|步，然后同时前进，相遇的第一个点为相交的第一个点。

链表长度分别为n1,n2,重叠的个数L(0<L<min(n1,n2)),则总共遍历的次数为2(n1+n2)-L,时间复杂度O(n1+n2);用了常数个额外指针，空间复杂度O(1)。
'''

'''
归并法  12.py
主要思路为使用归并排序中的合并操作，使用归并的方法把这些链表来逐个归并。
具体而言，可以使用递归地方法，递归地合并已经扁平化的链表与当前的链表。
在实现的过程中，使用dowm指针来存储扁平化处理后的链表。

'''


